// // This is your Prisma schema file,
// // learn more about it in the docs: https://pris.ly/d/prisma-schema

// // Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// // Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Hospital {
  id                       Int    @id @default(autoincrement())
  hospital_name            String @unique
  hospital_email           String @unique
  hospital_phone           String @unique
  hospital_whatsapp_number String @unique
}

model Department {
  id      Int      @id @default(autoincrement())
  name    String   @unique
  doctors Doctor[]
}

model Doctor {
  id               Int                  @id @default(autoincrement())
  name             String
  email            String
  phone_number     String
  qualification    String
  departmentId     Int
  departmentName   String               @default("Unknown")
  department       Department           @relation(fields: [departmentId], references: [id])
  userId           Int? // Links to the User model
  user             User?                @relation(fields: [userId], references: [id], name: "DoctorUser", onDelete: SetNull) // Corrected relation name
  availableFrom    String?
  slotDuration     Int?
  doctorType       String?              @default("Regular")
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  availability     DoctorAvailability[] @relation(name: "DoctorToAvailability")
  unavailableDates UnavailableDates[]   @relation(name: "DoctorToUnavailableDate")
  appointments     Appointment[]        @relation(name: "DoctorAppointments")
  bookedSlots      BookedSlot[]         @relation(name: "DoctorToBookedSlot")
  unavailableSlots UnavailableSlot[]    @relation(name: "DoctorToUnavailableSlot") // Relation to UnavailableSlot
  extraSlots       ExtraSlot[]          @relation(name: "DoctorToExtraSlot") // Relation to ExtraSlot
}

model User {
  id           Int            @id @default(autoincrement())
  username     String         @unique
  password     String
  role         UserRole
  createdAt    DateTime       @default(now())
  loggedInDate String?
  loggedInTime String?
  doctors      Doctor[]       @relation("DoctorUser") // Relation to Doctor model
  appointments Appointment[]  @relation("UserAppointments") // Relation to Appointment model
  activeTokens ActiveToken[] // Relation to the ActiveToken model
  Notification Notification[]

  @@map("users")
}

model DoctorAvailability {
  id            Int      @id @default(autoincrement())
  doctorId      Int?
  day           String
  availableFrom String
  slotDuration  Int      @default(20)
  date          String? // Adding date column to handle future data
  isFuture      Boolean? @default(false) // Adding isFuture column to handle future data
  startDate     String? // Adding startDate column to handle future data
  endDate       String? // Adding endDate column to handle future data
  doctor        Doctor?  @relation(fields: [doctorId], references: [id], onDelete: SetNull, name: "DoctorToAvailability")

  createdAt DateTime  @default(now()) // Track when the record was created
  updatedAt DateTime? @updatedAt // Track when the record was last updated
}

model UnavailableDates {
  id       Int      @id @default(autoincrement())
  doctorId Int?
  date     DateTime

  doctor Doctor? @relation(fields: [doctorId], references: [id], onDelete: SetNull, name: "DoctorToUnavailableDate")
}

model Appointment {
  id             Int               @id @default(autoincrement())
  patientName    String
  phoneNumber    String
  email          String
  doctorId       Int?
  doctor         Doctor?           @relation(fields: [doctorId], references: [id], name: "DoctorAppointments", onDelete: SetNull)
  doctorName     String
  department     String
  date           String
  time           String
  requestVia     String?
  smsSent        Boolean?          @default(false)
  emailSent      Boolean?          @default(false)
  messageSent    Boolean?          @default(false)
  status         AppointmentStatus @default(pending)
  created_at     DateTime          @default(now())
  updated_at     DateTime          @updatedAt
  userId         Int?
  user           User?             @relation(fields: [userId], references: [id], name: "UserAppointments")
  lockedBy       Int? // Stores the user ID who locked the appointment
  lockExpiresAt  DateTime? // Stores the expiration of the lock
  patientId      Int?
  prnNumber      Int?
  patient        Patient?          @relation(fields: [patientId], references: [id], name: "AppointmentToPatient")
  checkedIn      Boolean?          @default(false)
  remainder1Sent Boolean?          @default(false)
  remainder2Sent Boolean?          @default(false)

  @@map("appointments")
}

enum AppointmentStatus {
  pending
  confirmed
  cancelled
  completed
  rescheduled
}

model BookedSlot {
  id        Int      @id @default(autoincrement())
  doctorId  Int?
  doctor    Doctor?  @relation(fields: [doctorId], references: [id], onDelete: SetNull, name: "DoctorToBookedSlot")
  date      String
  time      String
  complete  Boolean? @default(false) // Adding the complete status column
  createdAt DateTime @default(now())
}

model UnavailableSlot {
  id       Int    @id @default(autoincrement())
  doctorId Int?
  date     String // Change from DateTime to String
  time     String // Time in HH:MM format

  doctor Doctor? @relation(fields: [doctorId], references: [id], onDelete: SetNull, name: "DoctorToUnavailableSlot")

  @@unique([doctorId, date, time])
}

enum UserRole {
  super_admin
  sub_admin
  admin
  doctor
  unknown
}

model Patient {
  id           Int           @id @default(autoincrement())
  prn          Int           @unique
  name         String
  phoneNumber  String
  email        String
  created_at   DateTime      @default(now())
  updated_at   DateTime      @updatedAt
  appointments Appointment[] @relation(name: "AppointmentToPatient")
}

model ActiveToken {
  id         Int     @id @default(autoincrement())
  userId     Int
  token      String  @unique @db.VarChar(500)
  loggedInAt String
  lastActive String
  isActive   Boolean @default(true) // Field to mark if the session is active or not
  user       User    @relation(fields: [userId], references: [id])

  @@map("active_tokens")
}

model ExtraSlot {
  id       Int     @id @default(autoincrement())
  doctorId Int?
  doctor   Doctor? @relation(fields: [doctorId], references: [id], onDelete: SetNull, name: "DoctorToExtraSlot")
  date     String
  time     String

  @@index([doctorId, date, time], name: "unique_slot") // Optional: Unique combination of doctor, date, and time
}

model Notification {
  id         Int       @id @default(autoincrement())
  // userId     Int? // Nullable for broadcast notifications
  // user       User?     @relation(fields: [userId], references: [id])
  type       String // Type of notification (e.g., 'appointment_request', 'service_package', 'reminder')
  title      String // Title or short description of the notification
  message    String // Detailed content of the notification
  status     String    @default("unread") // 'unread', 'read', 'clicked'
  entityId   Int? // ID of the related entity (e.g., appointment ID, package request ID)
  entityType String? // Type of related entity ('appointment', 'service_package')
  createdAt  DateTime  @default(now()) // Timestamp when the notification was created
  sentAt     DateTime? // Timestamp when the notification was sent
  viewedAt   DateTime? // Timestamp when the notification was viewed or clicked
  isCritical Boolean   @default(false) // Whether the notification is critical
  expiresAt  DateTime? // Expiration timestamp for the notification
  targetRole String? // Role of the target user (e.g., 'super_admin', 'admin', 'doctor')
  User       User?     @relation(fields: [userId], references: [id])
  userId     Int?
}
