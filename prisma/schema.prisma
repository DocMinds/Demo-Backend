// // This is your Prisma schema file,
// // learn more about it in the docs: https://pris.ly/d/prisma-schema

// // Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// // Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

// generator client {
//   provider = "prisma-client-js"
// }

// datasource db {
//   provider = "mysql"
//   url      = env("DATABASE_URL")
// }

// model Department {
//   id      Int      @id @default(autoincrement())
//   name    String   @unique
//   doctors Doctor[]
// }

// model Doctor {
//   id               Int                  @id @default(autoincrement())
//   name             String
//   email            String
//   phone_number     String
//   qualification    String
//   departmentId     Int
//   departmentName   String               @default("Unknown")
//   department       Department           @relation(fields: [departmentId], references: [id])
//     userId           Int?                 // Linking to the User table
//   user             User?                @relation(fields: [userId], references: [id])
//   availableFrom    String? // New field for available timing
//   slotDuration     Int? // New field for slot duration
//   createdAt        DateTime             @default(now())
//   updatedAt        DateTime             @updatedAt
//   availability     DoctorAvailability[] @relation(name: "DoctorToAvailability")
//   unavailableDates UnavailableDates[]   @relation(name: "DoctorToUnavailableDate")
//   appointments     Appointment[] // Fixed field name to follow naming convention
//   bookedSlots      BookedSlot[]         @relation(name: "DoctorToBookedSlot")

// }

// model DoctorAvailability {
//   id            Int    @id @default(autoincrement())
//   doctorId      Int
//   day           String // e.g., "mon", "tue", etc.
//   availableFrom String // e.g., "09:00-11:00"
//   slotDuration  Int    @default(20) // Slot duration in minutes

//   // Relation to Doctor
//   doctor Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade, name: "DoctorToAvailability")
// }

// model UnavailableDates {
//   id       Int      @id @default(autoincrement())
//   doctorId Int
//   date     DateTime

//   doctor Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade, name: "DoctorToUnavailableDate")
// }

// model Appointment {
//   id          Int               @id @default(autoincrement())
//   patientName String
//   phoneNumber String
//   email       String
//   doctorId    Int
//   doctor      Doctor            @relation(fields: [doctorId], references: [id])
//   doctorName  String
//   department  String
//   date        String
//   time        String
//   requestVia  String?
//   smsSent     Boolean?          @default(false)
//   emailSent   Boolean?          @default(false) // Added new field for email notification
//   status      AppointmentStatus @default(pending)
//   created_at  DateTime          @default(now())
//   updated_at  DateTime          @updatedAt
//   userId      Int? // Added new field to store the user who created the appointment
//   user        User?             @relation(fields: [userId], references: [id], onDelete: SetNull, name: "UserAppointments") // Linking to User model

//   @@map("appointments")
// }

// enum AppointmentStatus {
//   pending
//   confirmed
//   cancelled
//   completed
// }

// model BookedSlot {
//   id        Int      @id @default(autoincrement())
//   doctorId  Int
//   doctor    Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade, name: "DoctorToBookedSlot") // Added correct relation name
//   date      String // Store the date as a string (e.g., 'YYYY-MM-DD')
//   time      String // The booked time slot (e.g., '09:00-09:20')
//   createdAt DateTime @default(now())
// }

// model User {
//   id        Int      @id @default(autoincrement())
//   username  String   @unique
//   password  String
//   role      UserRole // super_admin, sub_admin, admin
//    doctors      Doctor[]      @relation("UserDoctors") // Corrected relation with Doctor model
//   createdAt DateTime @default(now())

//   // Relation
//   appointments Appointment[] @relation(name: "UserAppointments")

//   @@map("users")
// }

// enum UserRole {
//   super_admin
//   sub_admin
//   admin
//   doctor
//   unknown
// }
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Department {
  id      Int      @id @default(autoincrement())
  name    String   @unique
  doctors Doctor[]
}

model Doctor {
  id               Int                  @id @default(autoincrement())
  name             String
  email            String
  phone_number     String
  qualification    String
  departmentId     Int
  departmentName   String               @default("Unknown")
  department       Department           @relation(fields: [departmentId], references: [id])
  userId           Int? // Links to the User model
  user             User?                @relation(fields: [userId], references: [id], name: "DoctorUser") // Corrected relation name
  availableFrom    String?
  slotDuration     Int?
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt
  availability     DoctorAvailability[] @relation(name: "DoctorToAvailability")
  unavailableDates UnavailableDates[]   @relation(name: "DoctorToUnavailableDate")
  appointments     Appointment[]        @relation(name: "DoctorAppointments")
  bookedSlots      BookedSlot[]         @relation(name: "DoctorToBookedSlot")
}

model User {
  id           Int           @id @default(autoincrement())
  username     String        @unique
  password     String
  role         UserRole
  createdAt    DateTime      @default(now())
  doctors      Doctor[]      @relation("DoctorUser") // Relation to Doctor model
  appointments Appointment[] @relation("UserAppointments") // Relation to Appointment model

  @@map("users")
}

model DoctorAvailability {
  id            Int    @id @default(autoincrement())
  doctorId      Int
  day           String
  availableFrom String
  slotDuration  Int    @default(20)

  doctor Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade, name: "DoctorToAvailability")
}

model UnavailableDates {
  id       Int      @id @default(autoincrement())
  doctorId Int
  date     DateTime

  doctor Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade, name: "DoctorToUnavailableDate")
}

model Appointment {
  id            Int               @id @default(autoincrement())
  patientName   String
  phoneNumber   String
  email         String
  doctorId      Int
  doctor        Doctor            @relation(fields: [doctorId], references: [id], name: "DoctorAppointments")
  doctorName    String
  department    String
  date          String
  time          String
  requestVia    String?
  smsSent       Boolean?          @default(false)
  emailSent     Boolean?          @default(false)
  status        AppointmentStatus @default(pending)
  created_at    DateTime          @default(now())
  updated_at    DateTime          @updatedAt
  userId        Int?
  user          User?             @relation(fields: [userId], references: [id], name: "UserAppointments")
  lockedBy      Int? // Stores the user ID who locked the appointment
  lockExpiresAt DateTime? // Stores the expiration of the lock

  @@map("appointments")
}

enum AppointmentStatus {
  pending
  confirmed
  cancelled
  completed
}

model BookedSlot {
  id        Int      @id @default(autoincrement())
  doctorId  Int
  doctor    Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade, name: "DoctorToBookedSlot")
  date      String
  time      String
  createdAt DateTime @default(now())
}

enum UserRole {
  super_admin
  sub_admin
  admin
  doctor
  unknown
}
